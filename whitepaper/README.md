## Enigma：去中心化的隐私计算平台
### 摘要
Enigma是一个点对点网络，允许互不信任的多个参与方共同对数据进行存储和计算，并能彻底地保证数据的隐私。Enigma的计算模型建立在安全多方计算之上，具体地，我们采用了高度优化的可验证秘密分享体系。在隐私存储方面，我们使用了改进版的分散哈希表来保护共享秘密的数据。一个外部的区块链被用作该存储计算网络的控制器，管理着数据的访问控制权限和数字身份，并充当一个防篡改的事件日志库。保证金和服务费可以激励系统的运作，确保隐私计算的正确性和公平性。类似于比特币，Enigma也不需要一个可信的第三方，系统能够根据激励系统自主地控制个人数据。这是用户第一次能够在密码学保护下共享他们的隐私数据。
### 1.动机
从人类的早期历史来看，中心化是发展的一个主要竞争优势。具有中心化治理的社会制度能够发展出更先进的技术，累计更多的资源并实现快速的人口增长[1]。随着社会的演变，中心化的负面影响逐渐显露了出来：腐败、不平等、维持现状和滥用权力。事实证明，一定程度的权力分离[2]是必要的。如今，人们试图在这两种模型之间找到平衡，在去中心化治理的核验和制衡下做到集中控制，从而最大化产出和效率。
互联网的原始诉求是彻底的去中心化和自由[3]。然而，在过去的十年中，互联网的惊人增长引发了更大的中心化。少数大公司拥有网络的重要关口，因此占据了大量互联网数据。这些组织缺乏透明度和控制，再次揭示了中心化的负面影响: 操纵[4]，监视[5]和频繁的数据泄露[6]。
比特币[9]和其他区块链系统[10]（例如，以太坊）给出了一个全新的未来。互联网应用程序现在可以构建在去中心化架构上，其中没有任何一方拥有绝对的权力。区块链的公共性质保证了应用运行时的透明度，并留下了无可辩驳的活动记录，这为诚实行为提供了强有力的激励。比特币这种货币是第一个这样的应用程序，为互联网开启了一个新的范式。
然而，区块链的公共验证性也限制了其潜在的使用场景。现代应用程序使用大量数据，并对这些数据进行全面分析。这个限制意味着只有受信代码可以在区块链上运行[7]。问题是，现代应用程序往往需要对隐私数据进行大量加工。当前的区块链设计根本无法管理隐私，而且也不适用于繁重的计算。区块链系统的公共性质意味着隐私数据在流经网络中的每个全节点时会完全暴露。
这种情况下有一个奇怪的矛盾。最敏感的隐私数据似乎只能在中心化、不透明的和不安全的模型中存储和处理。我们认为这种模式导致了我们不得不接受灾难性的数据泄漏以及系统性的隐私缺失。

### 2.Enigma
Enigma是一个去中心化的隐私计算平台。我们的目标是使开发人员能够在没有可信第三方的情况下构建“privacy by design” (即GDPR隐私始于设计原则)、端到端的去中心化应用。
Enigma是隐私安全的。通过使用安全多方计算（sMPC或MPC），数据查询被转化为分布式的计算，无需受信任的第三方。具体来说，数据先被切分成不同的单元，然后分别发送到不同节点上，所有节点联合计算函数而不会将各自拥有的单元信息泄露给其他节点。没有任何一方能获取数据的整体；相反，每一方持有的只是毫无意义的、看似随机的一部分。
Enigma是可扩展的。与公共区块链不同的是，Enigma网络中的计算和数据存储不会复制到每个全节点。只有一小部分节点会在不同的数据单元上执行计算。减少存储计算的冗余能让网络支持更多高要求的计算。
Enigma带来的关键价值在于: 无需访问原始数据本身，也能够联合数据单元进行函数计算。例如，一组人想在不泄漏自己工资信息的情况下计算他们的平均工资，就可以只提供他们的工资数据的访问权(具体地，授权许可特定函数在工资数据单元上进行安全计算)。通过MPC，每个参与者只能了解到各自在小组中的相对位置，而对其他成员的工资一无所知。在实践中，MPC可以安全地评估任何程序，同时保持输入的秘密。
今天，共享数据是一个不可逆转的过程；一旦发送，就无法收回或限制其使用方式。提供数据的访问权用以安全计算是可逆的和可控制的，因为除了数据所有者之外，没有其他人能够看到原始数据。这给当前数据分析方法带来了根本性的变化。

### 3.设计概述
Enigma旨在连接现有的区块链和一个用以隐私密集型计算的链下网络。区块链系统可以通过数字签名和可编程的权限来实施访问控制。
代码在区块链（公共验证部分）和链下网络（隐私密集型的计算部分）上执行。 Enigma的执行方式确保了隐私和正确性，而单独的公共区块链只能保证后者。链下正确执行的证明被存储在区块链中用以审计。我们提供了一种脚本语言，支持使用隐私合约来设计端到端的分布式应用。这是一种更强大的智能合约变体，可以处理隐私信息（即，它们的状态不是严格公开的）。
这种脚本语言也是图灵完备的，但这点不像它的可伸缩性那般重要。公共区块链中的代码执行是去中心化的，但不是分布式的，因为每个节点冗余地执行相同的代码并保持相同的公共状态。在Enigma中，计算任务被有效地分发到网络的特定子集节点上。同时，如图1所示，一个解释器自动地拆分了隐私合约的执行，从而改善了运行时间，同时保持隐私和可验证性。

链下网络解决了以下几个区块链技术无法处理的问题：
1.储存。区块链不是通用数据库。 Enigma有一个去中心化的链下分布式哈希表（或DHT ），可供区块链访问，并且该表只存储数据的引用(即，MPC划分后的数据单元)，而不存储数据本身。在存储和访问控制协议被写入区块链之前，隐私数据应该在客户端进行加密。 Enigma使用定制化的脚本语言为这些任务提供简单的API。
2.隐私计算。 Enigma的网络确保正确执行代码，同时不会将原始数据泄露给任何计算节点。这是取代目前中心化隐私解决方案和可信覆盖网络的关键。这些中心化方案通常否定区块链的优势，而Enigma将要重新定义这点。计算模型在第5章中详细描述。
3.密集处理。即使隐私不是一个问题，区块链也无法扩展到需要大量交易清算的场景。Enigma的链下网络则可以用于运行被广播到区块链上的大量计算。

### 4.链下存储
链下节点构建了一个分布式数据库。每个节点都具有加密数据及其单元的独特视图，因此保证计算过程的隐私性和容错性。该数据库还可以存储未加密的大型公共数据（例如，文件）并将它们的访问地址记录到区块链。图2示例了单个节点的数据库视图。

在网络层面，该分布式存储的设计基于改进的Kademlia DHT协议[11]，增加了持久性和安全的点对点信道(这方面使用广播信道和公钥加密进行模拟)。该协议有助于有效地分发数据单元。我们修改了原始Kademlia距离度量，着重考虑了节点存储数据时(根据服务情况)被优先选择的概率。

### 5.隐私计算
在本节中，我们将描述Enigma的计算模型。我们首先简要介绍基于密码学最新进展的公开可验证安全MPC。然后，我们介绍一系列针对安全MPC的性能改进，这些改进使得其在网络规模很大时也能保证实用性。这些改进包括分层安全MPC、网络缩减和自适应电路。
为了使用Enigma，开发人员需要编写高级程序代码，其中公开部分在区块链上执行，隐私部分在Enigma平台上运行。我们称之为隐私合约，因为它们是可以处理隐私信息同时防止隐私泄露的智能合约。

#### 5.1 安全多方计算
##### 5.1.1隐私（被动攻击者）
姚期智在1982年提出了第一个安全两方计算协议[12]。在论文中，他提出了著名的百万富翁问题，即有两位百万富翁想要在不透露他们的实际资产值的情况下，知道谁更富有。在此后的几十年中，百万富翁问题被推广到MPC，同时进一步推广到N个参与方的问题。通用MPC协议都可以由基本MPC门电路组成。近年来，通用MPC主要有两种范式：姚期智的串联（布尔）电路[13]和基于秘密共享的MPC，后者更常用于生产系统（例如，[14]和[15]），同时也是我们关注的焦点。
一个阈值加密系统的定义为(t+1, n) - threshold，其中n是参与方的数量，t+1是解密一个被加密的秘密所需的最小参与方数量。秘密共享是阈值密码系统的一个例子，其中密码s被分割为n份并分散在n个参与方，重建s至少需要t+1个参与方。任何t个参与方的子集都无法获取该密钥的任何信息。线性秘密共享方案（LSSS）将秘密划分为多个共享单元(share)，而秘密是共享单元的线性组合。Shamir的秘密共享（SSS）是LSSS的一个例子，它在有限域Fp下使用多项式插值来保证秘密的安全[16]。具体来说，为了共享一个秘密s，我们选择一个随机的t次多项式q(x):

共享单元采用如下方法来获得：

然后，给定任何t+1个共享单元，我们就可以使用拉格朗日插值来重建q(x)，然后再使用s = q(0)来恢复秘密s。由于SSS是线性的，因此它也是加法同态的，即如果要对共享秘密进行加法和乘法的标量运算，可以直接在各共享单元上执行操作，无需与其他共享单元进行交互。公式如下：

两个不同共享秘密(如s1和s2)的乘法相比加法来说复杂得多。如果每一方都试图在本地计算两个秘密的乘积，那么从共享单元层面来看，计算就变成了2t次方的多项式。想高效快速地得到正确的结果就需要对多项式的次数进行缩减（2t→t）。在信息理论方面，为了保证这一操作的隐私性和正确性，需要一半以上的参与方是诚实的（即t <n/2）。如果我们限制对手的计算能力，那么即便出现任何数量的不诚实方都不会影响隐私性和正确性，但要确保公平性和结果的确定性的话，我们仍然要求半数以上的参与方是诚实的[17]。
性能方面，对乘法的二次多项式进行缩减的步骤中，包含了信息共享操作，这意味着所有的参与方都必须与其他各方（O(n^2)通信次数）进行交互，如果n太大，MPC将是不切实际的。虽然存在能够降低复杂度的优化方案，但这些方案是基于一定的假设的，无法在实际中使用。为了使安全MPC对于任意大型网络都是可行的，我们采用了5.2节中所描述的方法作为该问题的通用解决方案。
请注意，只需使用安全的加法和乘法协议，我们就可以为任何算术函数构建一个电路。同时为了确保图灵完整性，我们还需要处理控制流程。对于涉及秘密值的条件语句，我们就要评估语句的分支，如果是动态循环，就需要让语句执行更加随机。我们的通用MPC解释器正是基于这些核心概念和论文中提及的其他优化实现的。

5.1.2 正确性（恶意攻击者）
到目前为止，我们已经讨论了隐私性。活跃性（Liveness），即计算能够终止并且系统流程能够进行下去，也同样要求大多数节点是诚实的。之所以说活跃性建立在诚实多数的基础上，是因为活跃性包括且仅包括重建中间值和输出值。但是在目前的框架中，我们无法保证输出的正确性；任何一个参与方pi可以在整个计算过程中发送无效结果，使得最后的输出无效。虽然BGW [17]提出了一个可验证的MPC的信息理论解决方案，也给出了一个简单的实现，但它的实际复杂度可能与O（n^8）一样糟糕。
因此，我们的目标是设计一个对恶意攻击者安全的MPC框架，但具有与半诚实情况下相同的复杂度（O(n^2)），然后再进一步优化。
最近，Baum等人开发了一个可公开审计的安全MPC系统，即使所有计算节点都是暗中恶意的，或者除一个节点外其他节点都是主动恶意的，它都能确保正确[18]。他们最先进的结果是基于SPDZ协议（发音为speedz）[19]并依赖于一个公开的公告板来存储每次计算的轨迹，公共板只能插入数据，不能进行删除和修改。这允许任何审计方通过追踪公告板的轨迹来比较和检查输出是否正确。我们的系统使用区块链作为公告板，因此我们的整体安全性可以简化为托管区块链的安全性。
SPDZ。它是一种防御恶意攻击者（不诚实的多数）的协议，为MPC提供正确性保证。本质上，该协议由昂贵的离线（预处理）步骤组成，该步骤使用类同态加密（或SHE）来生成共享的随机性。在线阶段的计算类似于被动情况，并且不涉及昂贵的公钥加密，此时，每个共享单元被重新表示成共享及其MAC的组合，如下所示：

其中α是固定的秘密共享的MAC密钥，而⟨•⟩表示修改后的秘密共享方案，这也是加法同态的。⟨•⟩-sharing无需揭示全局MAC密钥α即可工作，因此α可以被重复使用。
跟前面类似，乘法相对加法更加复杂。乘法需要{⟨a⟩,⟨b⟩,⟨c⟩}三元组参与，这里c=ab，在预处理步骤中会生成许多这样的三元组。然后，给定两个秘密s1和s2，在⟨•⟩-sharing情况下，s = s1*s2的秘密共享是通过使用一个三元组来实现的:

如上所述，生成三元组是一个昂贵的SHE计算过程。包含了安全性证明过程的完整协议可在[18]中找到。验证部分通过如下的式子求解：

这里s可以是安全计算协议下的任意秘密的重建结果。直观地，这只是将MAC值与重建结果s和MAC密钥α的乘积进行比较的计算过程。我们没有进行实际秘密比较(而通过MAC值)的原因是这样可以让α仍然保持私密并且可以被重复使用。
我们现在可以看到⟨•⟩-sharing具有与SSS类似的属性，即它是加法同态的并且只需要一轮重新共享的过程就可以被用于乘法（O(n^2)通信复杂度）。然而与SSS相比，即便n个参与方中有n-1个是主动的攻击者，它同样可以确保安全性。离线的计算过程很容易进行计算摊销，可以在其他计算运行时做到并行地计算，因此它不会影响整体效率。
公开可验证的SPDZ。在公开可验证的情况下，MAC和计算轨迹的提交被存储在区块链中，因此即使所有n个计算方都是恶意的，该方案也是安全的。我们遵循[18]的表示，它定义了[•] –sharing，如下:

其中s是秘密，r是随机值，c = g^s * h^r是Pedersen承诺，g，h用作生成器。[•]-sharing保留了加法同态属性，并且通过略微修改乘法协议，我们还可以重新实现相同的离线三元组({ a, b, c})生成过程。
这里的一个关键是节点在<•>-sharing上进行计算而不是在Pedersen承诺上进行计算。这些承诺值被存储在区块链中，可以被任何有输出的验证者寻址。即使计算节点违背了其承诺，审计方也能够发现这一点。


5.2 分层安全MPC
信息理论结果表明，安全MPC协议要求每个计算节点与所有其他节点进行恒定数量的交互（这需要O(n^2)通信复杂度）。在LSSS的情况下，该计算复杂度适用于乘法运算，而加法运算可以并行计算且无需相互通信。如前所述，安全的加法和乘法协议足以构建一个通用解释器来支持任何代码的安全执行[17]。

Cohen等人[20]最近提出了一种对数深度形式的分层MPC门控来模拟n方安全协议协议，如图3所示。我们将其扩展到LSSS，并且以增加计算复杂度为代价(这部分可并行)将原有的通信复杂度从二次降低成线性复杂度。图4说明了普通的MPC会如何受到参与方数量限制，而我们的实现(ps-MPC)可扩展到任意大型网络。


5.3 网络缩减
为了最大化网络的计算能力，我们引入了网络缩减技术，每次计算随机选择整个网络中一组子集节点来进行。随机选择过程优先根据负载平衡要求和节点的累积声誉来选择参与计算的节点，节点的累积声誉是通过他们被公开验证过的行为来衡量的。网络缩减确保了在任意时刻网络是被充分利用的。

5.4 适应性电路
在我们系统上执行的代码通过安全MPC分发，不会泄露用户的任何数据，除非一半以上不诚实的参与方勾结起来对网络进行攻击（t≥n/2）。用户输入和计算执行过程中的任何临时变量都不会被泄露。细心的读者会注意到，一个方法从输入到输出的过程中，中间结果通常会变得不那么具有可描述性，但信息更具有集中性。
对于简单函数或是涉及极少输入的函数来说，适应性电路不是必须要被采纳的，因为这些函数计算速度本身就很快，不需要再对这些函数进行额外的处理。
然而，对于代码量较大或是数据量较大的函数，我们可以在计算时动态地减少计算节点的数量，而不是在整个函数执行过程中使用固定数量的节点。具体来说，我们设计了一个前馈网络(如图5所示，从输入开始，中间结果一步步变化到输出)。图5的原始代码已经被重新组织过，我们首先处理输入中的加法门，然后处理乘法门。中间结果会与N/c个节点秘密共享，并且不断递归类似的过程。


5.5 脚本
如前所述，端到端去中心化应用是使用隐私合约开发的，隐私合约进一步划分为链上和链外执行部分。链外代码私密地返回结果，同时向区块链发送正确执行的证明。为简单起见，我们的脚本语言在语法上会与当前的编程语言类似。
我们对脚本语言进行了两个重要的扩展，见5.6和5.7。

5.6 私有数据类型
开发人员应使用private关键字指定私有对象，系统会自动确保涉及这些对象的任何计算都保持安全和私密。数据本身并不保存在私有对象中，私有对象中保存的是数据的引用。

5.7 数据访问
我们的系统中有三个不同的去中心化数据库，每个数据库都可以通过全局字典访问。具体内容如下：
1) 公开账本。区块链公开账本可以通过使用L来进行访问和操纵。例如，L [k]←1将在所有节点上更新密钥k。由于账本是完全公开的并且只能在账本上追加内容，因此整个历史记录也都会被公开账本存储，并且可以使用L.get(k, t)来访问(只读)。
2) DHT。链下数据存储在DHT上，并且可以用与公开账本相同的方式进行访问。默认情况下，数据在传输之前先在本地加密，只有签名方可以请求数据。使用DHT.set(k, v, p)来访问键k对应的值v，谓词p：X→{0,1}设置了访问时的规则，当且仅当规则被满足时才能进行访问。我们提供了几种语言内置谓词，例如限制访问权限到一个公钥列表上。如果不进行加密，则默认谓词为∀x p(x)= 1，这种情况下数据是公开的，被分布存储在链下。
3) MPC。从语法上讲，使用MPC等同于DHT，但是底层的过程是不同的。比如，执行MPC.set(k, v, p)将秘密地共享v。共享单元被分发给潜在的计算参与方，他们在其本地中各自存储了一份共享单元。现在p可以通过ref←MPC [k]来指定谁可以使用数据来计算，同时不透露v。默认情况下，只有原始的数据分发者可以通过v←MPC.declassify(k)来请求原始数据。这一操作类似于共享过程，从各方收集共享单元并在本地重建秘密。另外，拥有相同共享身份的任何其他参与方可以引用该数据以进行计算。有关共享身份的详细信息，请参阅第6.1节。
为简单起见，我们为L、DHT和MPC字典中的所有键使用了单个命名空间，而实际上可以使用更精细的粒度，以便可以将它们分段为数据库、表和更精细的层次结构。
